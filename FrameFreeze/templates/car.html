<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AirSwipe Racer â€“ Compact Gesture Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0;}
    html, body {
      height: 100%; width: 100%; overflow: hidden;
      font-family: "Poppins", Arial, sans-serif;
      background: radial-gradient(circle at top,#e0f2ff,#9bd1ff);
      color: #111827;
      display: flex; align-items: center; justify-content: center;
    }
    .game-wrapper {
      position: relative;
      width: 340px;
      max-width: 95vw;
      background: #f9fafb;
      border-radius: 24px;
      padding: 16px 0 38px;
      box-shadow:
        0 18px 50px rgba(15,23,42,.3),
        0 0 0 1px rgba(148,163,184,.22);
      text-align: center;
    }
    h1 {
      font-size: 1.5rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      margin-bottom: 0.25rem;
    }
    .controls {
      font-size: 0.9rem;
      opacity: 0.78;
      margin-bottom: 0.8rem;
      line-height: 1.3;
      padding: 0 12px;
    }
    .canvas-frame {
      position: relative;
      width: 320px;
      height: 460px;
      margin: 0 auto;
      border-radius: 18px;
      background: #98cdf7;
      box-shadow: inset 0 0 20px #56aafdcc;
      overflow: hidden;
    }
    #gameCanvas {
      border-radius: 18px;
      width: 320px;
      height: 460px;
      display: block;
    }
    #webcam {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 110px;
      height: 80px;
      border-radius: 12px;
      border: 2px solid #55b8e2;
      box-shadow: 0 6px 22px #222b;
      background: #efefef;
      object-fit: cover;
      z-index: 5;
    }
    .gesture-label {
      position: absolute;
      right: 12px;
      top: 102px;
      background: #e8f8fff7;
      color: #0798c9;
      border-radius: 12px;
      padding: 6px 13px;
      font-weight: 500;
      font-size: 1rem;
      min-width: 115px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      text-align: center;
      user-select: none;
      z-index: 5;
      transition: opacity 0.3s ease;
    }
    #restartBtn {
      margin-top: 16px;
      padding: 12px 22px;
      font-size: 0.9rem;
      font-weight: 600;
      color: #f9fafb;
      border: none;
      border-radius: 999px;
      width: 100%;
      max-width: 320px;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      box-shadow: 0 12px 30px rgba(22,163,74,0.5);
      cursor: pointer;
      transition: box-shadow 0.2s ease, transform 0.2s ease;
      user-select: none;
    }
    #restartBtn:hover {
      box-shadow: 0 16px 38px rgba(22,163,74,0.65);
      transform: translateY(-1px);
    }
    #restartBtn:active {
      box-shadow: 0 8px 18px rgba(22,163,74,0.45);
      transform: translateY(1px);
    }
    .hidden {display:none;}
  </style>
</head>
<body>
  <div class="game-wrapper">
    <h1>AIRSWIPE RACER</h1>
    <div class="controls">
      <p>Swipe your hand left/right to steer your car.</p>
      <p>Show index finger to speed up.</p>
      <p>Show open palm to pause/unpause.</p>
    </div>
    <div class="canvas-frame">
      <video id="webcam" autoplay muted playsinline></video>
      <canvas id="gameCanvas" width="320" height="460"></canvas>
      <div id="gestureLabel" class="gesture-label">(Show hand)</div>
    </div>
    <button id="restartBtn" class="hidden">Play Again</button>
  </div>

  <script>
    // Hand tracking with MediaPipe Hands
    const videoEl = document.getElementById("webcam");
    const gestureLabel = document.getElementById("gestureLabel");
    let handDetector = null;
    let lastHandX = 0.5;
    let lastPalmState = false;
    let gamePaused = false;
    let gestureCooldown = 0;

    async function initHandTracking() {
      if(window.tf && tf.setBackend){
        await tf.setBackend("webgl");
        await tf.ready();
      }
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 240, height: 140 } });
      videoEl.srcObject = stream;
      await videoEl.play();

      handDetector = await handPoseDetection.createDetector(
        handPoseDetection.SupportedModels.MediaPipeHands,
        { runtime: "mediapipe", modelType: "lite", solutionPath: "https://cdn.jsdelivr.net/npm/@mediapipe/hands" }
      );
      requestAnimationFrame(handLoop);
    }

    // Count fingers up (except thumb)
    function countFingers(hand) {
      let fingers = 0;
      if (hand[8].y < hand[6].y) fingers++;     // index
      if (hand[12].y < hand[10].y) fingers++;   // middle
      if (hand[16].y < hand[14].y) fingers++;   // ring
      if (hand[20].y < hand[18].y) fingers++;   // pinky
      return fingers;
    }
    function detectPalm(hand){
      return countFingers(hand) >= 4;
    }

    async function handLoop(){
      if(gestureCooldown > 0) gestureCooldown--;
      if(handDetector && videoEl.readyState === 4){
        try {
          const hands = await handDetector.estimateHands(videoEl, { flipHorizontal: true });
          if(hands.length > 0){
            const hand = hands[0].keypoints;
            const normX = hand[9].x / videoEl.videoWidth;

            // Steering (car X)
            lastHandX = normX;

            // Speed Up Gesture (index only)
            const fingersUp = countFingers(hand);
            if(fingersUp === 1 && hand[8].y < hand[6].y && gestureCooldown <= 0){
              speedMultiplier += 0.15;
              gestureCooldown = 15;
            }

            // Pause Gesture (open palm)
            const palm = detectPalm(hand);
            if(palm !== lastPalmState && palm && gestureCooldown <= 0){
              gamePaused = !gamePaused;
              gestureCooldown = 30;
            }
            lastPalmState = palm;

            gestureLabel.textContent = gamePaused ? "ðŸ– Paused" : "Use hand to steer";
            return;
          }
          gestureLabel.textContent = "(Show hand)";
          lastHandX = 0.5;
          lastPalmState = false;
        }
        catch { gestureLabel.textContent = "(Camera error)"; }
      }
      requestAnimationFrame(handLoop);
    }
    initHandTracking();

    // Game setup
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const restartBtn = document.getElementById("restartBtn");
    const W = canvas.width, H = canvas.height;
    const horizonY = 130, roadHeight = H - horizonY, roadWidthNear = 280, roadWidthFar = 60;
    const laneCount = 3;
    let playerLane = 1;
    let laneSwitchCooldown = 0;
    let enemyCars = [];
    let score = 0;
    let baseSpeed = 0.95;
    let speedMultiplier = 1;
    let gameOver = false;
    let lastTime = 0;

    function trySwitchLane(dir){
      if(laneSwitchCooldown > 0) return;
      const newLane = playerLane + dir;
      if(newLane >= 0 && newLane < laneCount){
        playerLane = newLane;
        laneSwitchCooldown = 100;
      }
    }

    function laneCenterXAtDepth(laneIndex, z){
      const rw = roadWidthFar + (roadWidthNear - roadWidthFar)*z;
      const laneW = rw/laneCount;
      const center = W/2;
      const offset = (laneIndex - (laneCount-1)/2)*laneW;
      return center + offset;
    }

    function screenYFromDepth(z){ return horizonY + z*roadHeight; }

    function spawnEnemy(){
      let lane = Math.floor(Math.random()*laneCount);
      enemyCars.push({ lane, z: 0, color: Math.random()>0.6?"#d97706":"#067cf5", speed: 4.2 + Math.random()*1.7 });
    }

    function initEnemies(){
      enemyCars = [];
      for(let i=0; i<2; i++) spawnEnemy();
    }

    function drawRoad(){
      const cx = W/2;
      ctx.fillStyle = "#e5eef3";
      ctx.beginPath();
      ctx.moveTo(cx - roadWidthFar/2, horizonY);
      ctx.lineTo(cx + roadWidthFar/2, horizonY);
      ctx.lineTo(cx + roadWidthNear/2, H);
      ctx.lineTo(cx - roadWidthNear/2, H);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "#fafafc";
      ctx.lineWidth = 3;
      ctx.setLineDash([10, 16]);
      for(let lane=-1; lane<=1; lane++){
        ctx.beginPath();
        ctx.moveTo(cx + lane*roadWidthFar/6, horizonY+22);
        ctx.lineTo(cx + lane*roadWidthNear/6, H-12);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      ctx.strokeStyle = "#ff7a3c";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(cx - roadWidthFar/2, horizonY);
      ctx.lineTo(cx - roadWidthNear/2, H);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(cx + roadWidthFar/2, horizonY);
      ctx.lineTo(cx + roadWidthNear/2, H);
      ctx.stroke();
    }

    function drawCar(x,y,color){
      ctx.save();
      ctx.translate(x,y);
      // shadow
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.ellipse(0,26,28,10,0,0,2*Math.PI);
      ctx.fill();
      ctx.globalAlpha = 1;
      // body
      ctx.fillStyle = color;
      ctx.fillRect(-25,-9,50,55);
      ctx.fillStyle = "#36d0d3";
      ctx.fillRect(-18,2,36,25);
      ctx.fillStyle = "#fff";
      ctx.fillRect(-12,9,24,13);
      // wheels
      ctx.fillStyle = "#222832";
      ctx.fillRect(-23,-9,11,11);
      ctx.fillRect(12,-9,11,11);
      ctx.fillRect(-23,31,11,11);
      ctx.fillRect(12,31,11,11);
      ctx.restore();
    }

    function drawPlayerCar(){
      playerX = laneCenterXAtDepth(playerLane,1);
      playerX = playerX + (lastHandX - ((playerLane)/(laneCount-1)))*80; // small side offset by hand for smoothness
      drawCar(playerX, H-110, "#0d9488");
    }

    function drawEnemyCar(e){
      let x = laneCenterXAtDepth(e.lane, e.z);
      let y = screenYFromDepth(e.z);
      drawCar(x,y,e.color);
    }

    function update(dt){
      if(laneSwitchCooldown > 0) laneSwitchCooldown-=dt;
      if(gamePaused || gameOver) return;
      score += dt * 0.02 * speedMultiplier;
      for(const e of enemyCars){
        e.z += baseSpeed * speedMultiplier * 0.0018 * dt;
        if(e.z > 1.3){
          e.z = 0;
          e.lane = Math.floor(Math.random() * laneCount);
          e.color = Math.random() > 0.6 ? "#d97706" : "#067cf5";
          e.speed = 4.2 + Math.random()*1.5;
        }
        if(e.lane === playerLane && e.z > 0.7 && e.z < 0.92) gameOver=true;
      }
      // Spawn more enemies as score increases
      const desiredCount = Math.min(6 + Math.floor(score/2000), 12);
      while(enemyCars.length < desiredCount) spawnEnemy();
    }

    function drawHUD(){
      ctx.fillStyle = "#111827";
      ctx.font = "bold 20px Poppins, Arial, sans-serif";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + Math.floor(score), 15, 40);
      ctx.font = "bold 26px Poppins, Arial, sans-serif";
      ctx.textAlign = "right";
      ctx.fillText("Speed: x" + speedMultiplier.toFixed(2), W - 15, 40);
      if(gamePaused){
        ctx.fillStyle = "#ed1c24cc";
        ctx.font = "bold 28px Poppins, Arial, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("PAUSED", W/2, H/2);
      }
    }

    function drawGameOver(){
      ctx.fillStyle = "rgba(15,23,42,0.6)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "#f9fafb";
      ctx.textAlign = "center";
      ctx.font = "bold 28px Poppins, Arial, sans-serif";
      ctx.fillText("CRASHED!", W/2, H/2 - 10);
      ctx.font = "16px Poppins, Arial, sans-serif";
      ctx.fillText("Score " + Math.floor(score), W/2, H/2 + 18);
      ctx.font = "12px Poppins, Arial, sans-serif";
      ctx.fillText("Click Play Again or refresh to restart", W/2, H/2 + 42);
    }

    function loop(timestamp){
      if(!lastTime) lastTime=timestamp;
      const dt = timestamp - lastTime;
      lastTime=timestamp;
      ctx.clearRect(0,0,W,H);
      drawRoad();
      drawPlayerCar();
      enemyCars.forEach(drawEnemyCar);
      drawHUD();
      if(!gameOver){
        update(dt);
        requestAnimationFrame(loop);
      } else {
        drawGameOver();
        restartBtn.classList.remove("hidden");
      }
    }

    restartBtn.addEventListener("click", () => {
      score=0; speedMultiplier=1; playerLane=1; gameOver=false; gamePaused=false;
      enemyCars = [];
      lastTime=0;
      restartBtn.classList.add("hidden");
      initEnemyCars();
      requestAnimationFrame(loop);
    });

    function initEnemyCars(){
      enemyCars = [];
      for(let i=0; i<2; i++) spawnEnemy();
    }

    // Keyboard controls fallback
    document.addEventListener("keydown", (e) => {
      if(gameOver) return;
      if(e.key === "ArrowLeft") trySwitchLane(-1);
      if(e.key === "ArrowRight") trySwitchLane(1);
      if(e.key === "ArrowUp") speedMultiplier += 0.18;
      if(e.key === "ArrowDown") speedMultiplier -= 0.12;
      if(e.key === " ") gamePaused = !gamePaused;
    });

    initEnemyCars();
    let lastTime = 0;
    requestAnimationFrame(loop);

  </script>
</body>
</html>
